_______________________
Constructors
_______________________

once we creates an object compulsary we should perform initialization then only the object is in a position to respond properly.
whenever we are creating an object some peace of the code will be executed automatically to perform initialization of the object this peace of the code is nothing but constructor. Hence the main purpose of constructor is to perform initialization of an object 

e.g

class Student{
	String name;
	int rollno;

	public Student(String name, int rollno){
		this.name = name;
		this.rollno = rollno;
	}

	public static void main(String[] args){
		Strudent s1 = new Student("Test123", 20);
		Strudent s2 = new Student("xyz456", 30);
	}
}

Note : The main purpose of constructor is to perform initialization of an object but not to create object.


Difference between Constructor and instance block.

The main purpose of constructor is to perform initialization of an object.
But otherthan initialization if we want to perform any activity for every object creation then we should go for instance block (like updating one entry in the database for every object creation or incrementing count value for every object creation etc).

both constructor and instance block have there won different purposes and replacing one concept with another concept may not work always.

both constructor and instance block will be executed for every object creation but instance block first followed by constructor.


Demo program to print number of objects created for a class.

class Test{
	static int count = 0;
	{
		count++;
	}
	Test(){
		
	}

	Test(int i){
		
	}
	Test(double d){
		
	}
	public static void main(String[] args){
		Test t1 = new Test();
		Test t2 = new Test(10);
		Test t3 = new Test(20.5);
		System.out.println("Count " + count);	
	}

}

_________________________________
Rules of writing constructors:	 |
_________________________________|

1. Name of the class and name of the constructor must be matched.
2. Return type concept is not applicable for constructor even void also.
3. By mistake if we are trying to declare return type for the constructor then we won't get any compile-time error because compiler treats it as a method.

e.g

class Test{
	void Test(){
		System.out.println("It is method but not constructor");
	}

	public static void main(String[] args){
		Test t = new Test();

		t.Test();
	}
}

output : 
It is method but not constructor

hence it is leagle (but stupid) to have a method whose name is exactly same as class name.

The only applicable modifiers for constructors are public, private, protected, default if we are trying to use any other modifier we will get compile time error. 

class Test{
	static Test(){}	//CE: Modifier static not allowed hear.
}

Compiler is responsible to generate default constructor but not JVM 
if we are not writting any constructor then only compiler will generate default constructor i.e. if we are writting atlist one constructor compiler won't generate default constructor hence every class in java can contain constructor it may be default constructor generated by compiler or costumized constructor explicitly provided by compiler but not both symeltuniously.


_________________________________
Protoype of default constructor
_________________________________

1. It is always no-arg constructor 
2. the access modifier of default constructor is exactly same as access modifier of class (this rule is applicable only for public and default)
3. it contains only one line super();
			     ________

It is a no-argument call to super class constructor.


Programmers code								Compiler generated code
__________________________________________________________________________________________________________

class Test{									class Test{
											Test(){
}												super();
											}

___________________________________________________________________________________________________________
public class Test{								public class Test{
											public Test(){
												super();					
												}
}											}

_____________________________________________________________________________________________________________
public class Test{								public class Test{
	void Test(){									public Test(){
	}											super();
}											}

											void Test(){
												}
											}

______________________________________________________________________________________________________________
class Test{									class Test{
	Test(){										Test(){
												super();
	}											}
}											}

_______________________________________________________________________________________________________________
class Test{									class Test{
	Test(){										Test(){
		super();									super();
	}										}
}										}

________________________________________________________________________________________________________________
class Test{									class Test{
	Test(){										Test(){
		this(10);									this(10);
	}											}
	Test(int i){									Test(int i){
	}											super();
}												}
											}
_________________________________________________________________________________________________________________

The first line inside every constructor should be either super or this.
and if we are not writting any thing then compiler will always place super().

Case 1: we can use super() or this() only in first line of constructor. If we are trying to take anywhere else we will get compile time error

e.g

class Test{
	Test(){
		System.out.println("constructor");
		super();				//CE : call to super must be first statement in constructor
	}
}

case 2 : within the constructor we can take either super or this but not both symuleniously 

e.g 
class Test{
	Test(){
		super();
		this();		// CE : call to this must be first statement in constructor
	}
}

case 3 : we can use super() or this() only inside constructor if we are trying to use outside of constructor we will get compile time error

e.g 
class Test{
	public void m1(){
		super();		//CE : call to super must be first statement in constructor
		Sopln("Hello");
	}
}

i.e we can call a constructor directly from another constructor only 


********************** we can use only in first line
*  super or this     * we can use only one but not both symulteniously
********************** we can use only in constructor


super(), this()						super, this
__________________________________________________________________________
1. These are constructor calls			These are keywords
to call super class and current			to referrer super class and
class constructors				current class instance members

2. we can use only in constructors		we can use anywhere except static area
as first line 

3. we can use only once in constructor 		we can use any number of times.

e.g

class Test{
	public static void main(String[] args){
		System.out.println(super.hashCode());	//non static variable super can't be referenced from a static context.
	}
}

________________________
Overloaded constructors |
________________________|

within a class we can declare multiple constructors and all these constructors having same name but different type of arguments. Hence all these constructors are considered as overloaded constructors. Hence overloading concept applicable for constructors.

e.g
class Test{
	Test(){
		Test(10);
		sopln("noarg");
	}
	Test(int i){
		Test(10.5);
		sopln("int args");
	}
	Test(double d){
		sopln("double args");
	}

	public static void main(String[] args){
		Test t1 = new Test();
		Test t2 = new Test(10);
		Test t3 = new Test(10.5);
		Test t1 = new Test(10l);
	}
}

output : 

double args
int args
no args

double args
int args

double args

double args

for constructors inheritance and overridding concepts are not applicable  but overloading concept is applicable 

every class in java including abstract class can contains constructor but interface doesn't contain constructor.


class Test{
	Test(){
				//valid
	}
}

abstract class Test{
	Test(){
				//valid
	}
}

interface Test{
	Test(){
				//invalid
	}
}

case 1 :
recursive method call is a runtime exception saying stackOverFlowError  but in out program if there is a chance of recursive constructor
						    --------------------
invocation then the code won't compile and we will get compile time error.
					
class Test{

	public static void m1(){
		m2();
	}
	public static void m2(){
		m1();
	}
	public static void main(String[] arg){
		m1();

		System.out.println("Hello");
	}
}

output : 

CE :StackOverflowError 

class Test{

	Test(){
		this(10);
	}
	Test(int i){
		this();
	}
	public static void main(String[] arg){

		System.out.println("Hello");
	}
}


output:

Exception : Recursive constructor invocation.

case 2 : 
class P{

}

class C extends P{

}

valid


class P{
	P(){

	}
}

class C extends P{

}

valid
 
class P{
	P(int n){
	}
}

class C extends P{

}

invalid : can not find symbol Symbol : constructor P() location :class P

Note 1 : 

1. if parent class contains any argument constructor then while writting child classes we have to take special care with respect to constructors.

2. whenever we are writting any argument constructor it is highly recommanded to write no-arg constructor also.

case 3 : 

class Parent{
	Parent() throws IOException{

	}
}
class Child extends Parent{
	Child(){
		super();
	}
}
output:
CE : UnreportedException 
	java.io.IOException in default constructor. 
e.g 2 

class Parent{
	Parent() throws IOException{

	}
}
class Child extends Parent{
	Child()throws IOException|Exception|Throwable{
		super();
	}
}


output : compile fine

NOte : 

if parent class throws any checked exception compulsary child class constructor should throw same checked exception or its parent.
otherwise the code won't compile.


Which of the following is valid 

a. the main purpose of constructor is to create an object. 			// invalid
b. the main purpose of constructor is to perform initialization of an object. 	//valid
c. the name of the constructor need not be same as class name.			//invalid
d. return type concept applicable for constructors but only void.		//invalid
e. we can apply any modifier for constructor.					//invalid
f. default constructor generated by JVM.					//invalid
g. compiler is responsible to generate default constructor.			//valid
h. compiler will always generate default constructor				//invalid
i. if we are not writting no-arg constructor then compiler will generate default constructor //invalid
j. every no argument constructor is laways default constructor			//false
k. default constructor is always no-arg constructor.				//true
l. the first line every constructor should be either super() or this() if we 
are not writting anything then compiler will generates this(). 			//false

m. for constructors both overloading and overrindding concepts are applicable 	//false

n. for constructor inheritance concept applicable but not overridding		//false
o. only concrid classes can contain constructor but abstract classes can't 	//false
p. interface can contain constructors						//false
q. recursive constructor invocation is a runtime exception.			//invalid
r. if parent class constructor throws some checked exception then compulsary child
class constructor should throw same checked exception or its child 		//false
 
    